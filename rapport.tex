\documentclass[a4paper,12pt]{report}
\include{Package}

\begin{document}

\include{PageDeGarde}


Dans ce présent rapport nous allons vous présenter les fonctions que nous avons implémentées dans le cadre du projet du cours d'informatique en deuxième année de bachelier en ingénieur civil. Nous vous détaillerons dans ce rapport la structure de notre programme, les décisions que nous avons prises, les difficultées rencontrées ainsi que les limites et problemes de notre implémentation, nous finirons par estimer la complexité de nos fonctions. Le code dans son entièreté ne se retrouvera pas dans ce rapport.

\section*{Structure du programme}
Les deux fonctions principales de notre programme étant relativement indépendantes dans leur implémentation et leurs besoins, nous avons décidé de déclarer les sous-fonctions relatives à chaque fonction à l'intérieur de celles-ci.
\begin{lstlisting}[frame=single] 
fun{Interprete Partition}
	--Sous-Fonctions--
fun{Mix Interprete Music}
	--Sous-Fonctions--
\end{lstlisting}

\subsection*{Intepréter une partition}
Globalement la structure de la fonction Interprete est reprise ci dessous. Nous avons veillé à ce qu'elle soit récursive terminale, pour cela nous avons donc créé une fonction InterpreteAux reprenant un certains nombre de paramètres en plus que l'originale. 
\begin{lstlisting}[frame=single] 
fun{Interprete Partition}
	fun{Flatten Partition} %Permet de "deplier" les partitions pour ne plus avoir de listes imbriquees
	fun{NoteToEchantillon Note Duree DemiTons} %Argument note=note etendue ! Demitons=0 si pas de transformations
	fun {DureeTot Partition} %Utile pour la transformation Duree 
	fun {InterpreteAux Partition Note Duree DemiTons Acc}
		case Partition
		[] nil %On renvoie l'accumulateur
		[] Note % decuple en plusieurs case en fonction du format de la note
		[] muet(TPartition)
		[] etirer(facteur:F TPartition)
		[] duree(seconde:S TPartition)
		[] bourdon(note:NoteB TPartition)
		[] transpose(demitons:DemiTons TPartition)
		[] H|T			
\end{lstlisting}

Notre fonction InterpreteAux a donc comme paramètres Partition, Note, Duree, DemiTons et Acc (un accumulateur). Regardons leur utilité plus en détail:
\begin{itemize}
\item Partition: rien de surprenant ici puisque la fonction interprete à pour but premier d'interpreter une partition. 
\item Note: par défaut = nil, cet argument est utile lors des transformations muet et bourdon.
\item Duree: utilisé pour les transformations duree et etirer. 1 par défaut.
\item Demitons: cas d'une transformation transpose. 0 par défaut
\item Acc: l'accumulateur comme on peut s'en douter est utile pour la récursion terminale, car au fur et à mesure qu'on parcourt la partition il stocke les notes converties en échantillons. 
\end{itemize}


Comme chaque transformation s'applique sur une partition, nous avons utilisé la récursion pour interpreter les partitions modifiées en changeant les différents paramètres de notre fonction auxiliaire. 


\subsection*{Mixer la musique}
Le gros de la structure de notre fonction Mix et des sous fonctions qu'elle utilise est donnée ci-dessous.

\begin{lstlisting}[frame=single] 
fun{Frequence Hauteur}
fun{Add List1 List2}
fun{EchantillonToAudio Echantillon Facteur Acc}
fun{ListEchantillonToAudio Echantillon Facteur}
fun{Clip Up Down MusicClip Facteur}
fun{RepetitionNfois N Music Facteur}
fun{RepetitionDuree Duree Musique Facteur}
fun{Echo Duree Decadence Repetition Music Facteur}
fun{Merge MusicWithIntensity Acc Facteur}
fun{Fondu Ouverture Fermeture Music Facteur}

fun{MixAux Interprete  Music Facteur  Acc}
	of nil then {Flatten Acc}
	[] voix(Voix) then {ListEchantillonToAudio Voix Facteur}
	[] partition(Partition) then {ListEchantillonToAudio {Interprete Partition} Facteur}
	[] wave(File) then {Projet.readFile File}
	[] renverser(MusicR) then{List.reverse {MixAux Interprete MusicR Facteur nil}}
	[] repetition(nombre:N MusicR) then{RepetitionNfois N MusicR Facteur}
	[] repetition(duree:S MusicR) then {RepetitionDuree S MusicR Facteur}
	[] clip(bas:Bas haut:Haut MusiC)  then {Clip Haut Bas MusiC Facteur}
	[] echo(delai:S MusicE) then {Echo S 1.0 1 MusicE Facteur}
	[] echo(delai:S decadence:D MusicE)then{Echo S D 1 MusicE Facteur}
	[] echo(delai:S decadence:D repetition:R MusicE)then {Echo S D R MusicE Facteur}
	[] fondu(ouverture:S1 fermeture:S2 MusicF) then {Fondu S1 S2 MusicF Facteur}
	[] fondu_enchaine(duree:S Music1 Music2) then
	[] couper(debut:S1 fin:S2 Music) then
	[] merge(MusicWithIntensity) then {Merge MusicWithIntensity nil Facteur}
	[] H|T then {MixAux Interprete T Facteur Acc|{MixAux Interprete H Facteur nil}}
\end{lstlisting}
La fonction Mix était plus exigente au niveau des transformations, pour plus de lisibilités nous avons donc fait des sous-fonctions pour chacun des cas pouvant se présenter. 
Par rapport aux argument de notre fonction MixAux, nous avons utilisé un Facteur pour le cas où on avait une musique avec intensité et un accumulateur pour faire de la récursion terminale.



\section*{Difficultés rencontrées, limitations et problèmes connus}
\begin{itemize}
\item Etant un binome de deux \textbf{non-musiciens}, le vocabulaire lié à la musique nous a posé quelques problèmes lors de la compréhension du problème, mais également lors de l'implémentation de certaines fonctions

\item Lors des différents tests de notre programme, nous avons eu des \textbf{parse error} à de nombreuses reprises, malheureusement Mozart n'est pas toujours très explicite dans ses erreurs et nous avons passé beaucoup de temps à les dénicher. 
 
\item Pas moyen de mettre des \textbf{points d'arret} dans Mozart lors des tests ce qui complique les recherches d'erreurs.

\item Un des problèmes connus de notre fonction est sans doute qu'à plusieurs reprises nous devons appliquer un Reverse (opération tout de meme relativement couteuse pour des listes de grande ampleur) sur les listes à lire ou créer. 

 
\end{itemize}


\section*{Complexité des fonctions}
\begin{itemize}
%\item Toutes nos fonctions ont une complexité spatiale en $\vartheta(1)$, car elles sont toutes réursives terminales.
%\item La fonction {Frequence Hauteur} a une complexité spaitale et temporelle en $\vartheta(1)$.

%\item Les fonction {Clip Up Down VecteurAudio}, {EchantillonToAudio Echantillon Facteur Acc} ont une complexité spatiale et temporelle en $\vartheta(n)$. %car elle doit parcourir tout le VecteurAudio et le réécrire. 
%\item La fonction {Add List1 List2} a une complexité spatiale en $\vartheta(n^2)$ et une complexité temporelle en $\vartheta(n)$

\item Fonction interprete: a une complexité spatiale en $\vartheta(1)$, car elle est récursive terminale.
Pour la complexité temporelle, la fonction Interprete en elle-meme est en  $\vartheta(n)$ et toutes les sous fonctions qu'elle utilise également, ce qui nous donne une complexité temporelle  générale pour la fonction en  $\vartheta(n)$
\item Fonction Mix: tout comme la fonction interprete, nous avons rendu la fonction mix récursive terminale, elle a donc une complexité spatiale en  $\vartheta(1)$. Par contre pour la complexité temporelle, la fonction Mix a une complexité temporelle en  $\vartheta(n)$, mais elle utilise certaines fonctions ayant une complexité en  $\vartheta(n^2)$ (par exemple al fonction Repetition) , elle a donc une complexité générale en  $\vartheta(n^2)$

\end{itemize} 


\section*{Extensions}
Nous avons réalisé l'extension {\large \textbf{lissage}} et pour cela nous avons utilisé l'enveloppe ADSR \footnote{\url{http://fr.wikipedia.org/wiki/Enveloppe_sonore}}. Nous avons opté pour une attaque qui part d'une intensité de 0 à 1 sur 2000 valeurs du vecteurs audio, ensuite un déclin exponentiel en base deux de 1 à 0.5 d'intensité (sur 8000 valeurs), on maintient l'intensité à 0.5 jusque 4000 échantillons avant la fin du vecteur et à partir de là on redescend de manière linéaire jusque 0.


\end{document}}